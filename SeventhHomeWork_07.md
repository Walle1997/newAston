# Почитать про принципы программирования KISS, DRY, YAGNI + почитать про "Антипаттерны" Чистого кода

###  1. KISS (Keep It Simple, Stupid):
   - Суть: Держите решения простыми. Сложные решения часто приводят к ошибкам и трудностям в поддержке.
   - Цель: Избегать излишней сложности там, где это возможно, и выбирать простые, понятные подходы.

### 2. DRY (Don't Repeat Yourself):
   - Суть: Избегайте дублирования кода. Если возникает необходимость писать один и тот же код дважды, следует вынести его в отдельную функцию или модуль.
   - Цель: Уменьшить количество дублирующегося кода, что упрощает его поддержку и развитие.

### 3. YAGNI (You Aren't Gonna Need It):
   - Суть: Не реализуйте функционал, который, вероятно, не будет нужен в будущем. Сосредоточьтесь на текущих требованиях.
   - Цель: Снизить сложность и избегать избыточной функциональности, которая может быть неиспользуемой.

## Антипаттерны чистого кода в JavaScript

Антипаттерны — это общие решения, которые могут быть приемлемыми на первый взгляд, но приводят к проблемам в будущем. Вот несколько антипаттернов, популярных в JavaScript:

### 1. "Годзилла" (God Object):
   - Создание объекта, который управляет слишком многими аспектами приложения, что делает его сложным и трудным для поддержки.

### 2. "Магические числа" (Magic Numbers):
   - Использование чисел без объяснения их значения (например, использование `3.14` без комментариев о том, что это).

### 3. Сложные функции:
   - Функции, которые выполняют более одной задачи или имеют большое количество параметров, затрудняют понимание и тестирование.

### 4. "Долгожитель" (Long-Living Variables):
   - Использование глобальных переменных или переменных, срок жизни которых больше необходимого, что может привести к неожиданным последствиям.

### 5. Отсутствие обработки ошибок:
   - Игнорирование ошибок или исключений, что может привести к сбоям приложения.

### 6. "Обратноосмысленные" (Spaghetti Code):
   - Код, который трудно читать и поддерживать из-за запутанной логики и связей между компонентами.


# Прочитать про способы хранения LocalStorage, SessionStorage и Cookie

### 1. LocalStorage
- Объем хранения: Обычно до 5-10 МБ, в зависимости от браузера.
- Срок хранения: Данные сохраняются до тех пор, пока не будут удалены, что позволяет хранить информацию между сессиями.
- Доступ: Доступно в любом окне браузера на том же источнике (доменная зона).
- Применение: Хорошо подходит для хранения данных, которые необходимо запомнить между сессиями, например, пользовательские настройки, информация о теме и т.д.
### 2. SessionStorage
- Объем хранения: Аналогично LocalStorage, может быть до 5-10 МБ.
- Срок хранения: Данные сохраняются только на время сессии. Они автоматически удаляются, когда вкладка или окно браузера закрывается.
- Доступ: Доступно только в рамках текущей вкладки или окна. Каждая вкладка имеет свое собственное хранилище.
- Применение: Подходит для временных данных, которые не должны сохраняться между сессиями.
### 3. Cookies
- Объем хранения: Обычно ограничено 4 КБ на одно cookie, но общее количество cookie на домене может варьироваться. 
- Срок хранения: Можно устанавливать для конкретной даты истечения или сохранять так, что они будут удалены при закрытии браузера (сессионные cookies).
- Доступ: Cookies доступны на сервере и клиенте, что позволяет отправлять их с запросами к серверу.
- Применение: Подходят для хранения идентификаторов сессии, пользовательских предпочтений, данных, которые нужно передавать на сервер и т.д.

# HTML / CSS - Базовая структура html документа, БЭМ методология

Любой HTML-документ можно разбить на несколько основных составляющих:

### Блок head
содержащий метаинформацию о нашем сайте. Данные из этого блока не отображаются непосредственно на странице, а служат для её описания, подключения стилей и скриптов.
### Блок body
является основным местом, где строится HTML-разметка. Данные в этом блоке будут обработаны и выведены в браузер.
Простейшая разметка в HTML5 выглядит следующим образом:

<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8">
  <title>Базовая разметка HTML</title>
</head>
<body>
  <h1>Code Basics</h1>
  <p>Бесплатные уроки по программированию и HTML для новичков</p>
</body>
</html>

 DOCTYPE (document type) — служебная информация для браузера, где описывается стандарт HTML, который нужно обработать. Текущий стандарт HTML5 поддерживается всеми браузерами, поэтому достаточно указать в первой строке документа <!DOCTYPE html>, который говорит, что наш документ размечен по стандарту HTML5.

Далее открывается парный тег <html> с атрибутом lang="ru". Указание языка также необходимо для браузеров, особенно если сайт рассчитан на массовую аудиторию, в том числе и за рубежом.

Во избежание ошибок, обе вышеописанные конструкции, при их отсутствии, будут добавлены браузером автоматически. В некоторых ситуациях браузеры могут добавить не те строки, которые вы бы хотели, и вместо обработки страницы по стандарту HTML5 браузер будет обрабатывать всё как HTML4, что приведёт ко множеству проблем, так как старые стандарты могут не знать о существовании многих тегов, таких как <main>, <nav> и так далее.

## БЭМ (Block, Element, Modifier)
это методология разработки интерфейсов, которая помогает организовать код и сделать его более поддерживаемым и переиспользуемым. Основная цель БЭМ — создать понятную структуру для разработки, с ясным и предсказуемым именованием классов, что облегчает работу в команде, поддержку и масштабирование кода.

### Принципы БЭМ

1. Четкость именования:
   - Имена классов должны быть понятными и описательными, чтобы разработчики могли легко понять, к какому элементу интерфейса они относятся.
   
2. Разделение на блоки:
   - Каждый компонент должен быть изолирован и независим, чтобы избежать конфликтов стилей и логики.
   
3. Сложные компоненты — из простых:
   - Сложные интерфейсы строятся из простых блоков и элементов, что облегчает процесс разработки и поддержку.

4. Модификаторы — для состояния:
   - Модификаторы могут использоваться для изменений состояния блока или элемента, например, для обозначения активного состояния, изменения цвета и так далее.


# Способы позиционирования контента на странице

## 1. Позиционирование с помощью стандартного потока (Static Positioning)


Это значение позиционирования по умолчанию. Элементы располагаются в обычном порядке, как они появляются в HTML-документе. Они располагаются один за другим, и их расположение зависит от порядка следования в коде.

## 2. Относительное позиционирование (Relative Positioning)


При использовании относительного позиционирования элемент размещается относительно своего первоначального положения в документе. Это позволяет сместить элемент относительно его обычного места, не изменяя расположение других элементов.

## 3. Абсолютное позиционирование (Absolute Positioning)


Элементы с абсолютным позиционированием располагаются относительно ближайшего предка с ненормальным позиционированием (отличным от `static`). Если таких предков нет, элемент будет размещен относительно `body` (всей страницы). 

## 4. Фиксированное позиционирование (Fixed Positioning)


Элементы с фиксированным позиционированием располагаются относительно окна просмотра (viewport). Они остаются на одном и том же месте при прокрутке страницы.

## 5. Прикрепленное позиционирование (Sticky Positioning)


Прикрепленное позиционирование комбинирует характеристики относительного и фиксированного позиционирования. Элемент ведет себя как относительный, пока не достигнет определенной позиции в окне просмотра, после чего будет фиксироваться на месте.


## 6. Flexbox


Flexbox — это метод компоновки, который позволяет упрощать размещение и выравнивание элементов внутри контейнера. Этот метод применяет свойства к родительскому элементу, чтобы автоматически управлять размером и расстановкой дочерних элементов.


## 7. Grid Layout


CSS Grid — это мощный метод для создания сложных макетов. Он разбивает пространство на строки и колонки, позволяя размещать элементы на сетке.


# Веса селекторов

## 1. Инлайновые стили (вес: 1000)
   - Эти стили применяются непосредственно к элементу с помощью атрибута `style`. 


## 2. ID селекторы (вес: 100)
   - Селекторы, которые выбирают элементы по их идентификатору, имеют высокий приоритет. 
   - Пример: `#header { color: blue; }`.

## 3. Класс селекторы, псевдоклассы и атрибутные селекторы (вес: 10)
   - Они имеют среднем приоритете и служат для выбора элементов по классам, псевдоклассам или атрибутам.
   - Пример: `.menu { color: green; }` или `a:hover { color: orange; }`.

## 4. Теговые и псевдоэлементы селекторы (вес: 1)
   - Эти селекторы имеют низкий приоритет и применяются к элементам по их тегам.
   - Пример: `div { font-size: 16px; }` или `p::first-line { font-weight: bold; }`.

#### Измерение веса селекторов

Вес селектора представляет собой кортеж из 4 компонентов (a, b, c, d):

- a: количество инлайновых стилей (максимум 1)
- b: количество ID селекторов
- c: количество классов, псевдоклассов и атрибутных селекторов
- d: количество тегов и псевдоэлементов

Например, для следующего CSS кода:

#header .nav a:hover {
    color: red;
}


Вес селектора будет:
- a = 0 (нет инлайновых стилей)
- b = 1 (один ID селектор)
- c = 2 (один класс и один псевдокласс)
- d = 1 (один тег)

Итак, вес этого селектора будет (0, 1, 2, 1), или в числовом виде: `0  1000 + 1  100 + 2  10 + 1  1 = 121`.