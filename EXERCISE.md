# const res = "B" + "a" + (1 - "hello");
# console.log(res);
В консоли будет выведен ответ 
### "BaNan" Объяснение:
1. "B" + "a". Здесь происходит конкатенация двух данных типа String, ввиду чего происходит банальное обединение строк, что в результате нам дает "Ba";

2. Следующим шагом идет вычисление значения в скобках согласно приоритетности вычисления (1 - "hello"). В данном случае при вычитании строки из числа происходит попытка привести строку "hello" к типовому значению числа, но т.к. строка в данном случае не может быть преобразована в число,
то результатом такого вычитания будет значение NaN.

3. Третим вычислением будет "Ba" + NaN. В данном случае, когда происходит конкатенация строки с NaN, NaN преобразуется в строку - "NaN". В итоге, происходит конкатенация строки "Ba" и строки "NaN", что в итоге даст ответ "BaNaN".

# const res2 = (true && 3) + "d";
# console.log(res2);
В данном случае ответ будеь равен
### "3d" Объяснение:

1. Согласно правилам приоритетности, сначала вычисляется значение в скобках (true && 3). Оператор && возвращает первое ложное или последнее истинное значение,
а т.к. true является истинным и 3 также является истинным, то значение в скобках будет равно просто 3.

2. Далее просиходит конкатенация числа со строкой: 3 + "d", что в итоге нам даст ответ равный "3d", т.к. "d" является строкой, то при конкатенации числа со строкой число преобразуется к типовому значению String - "3".

# const res3 = Boolean(true && 3) + "d";
# console.log(res3);
В данном случае ответом будет
### "trued" Объяснение:
1. Сначала производим расчет значения в скобках (true && 3), что будет равно 3, т.к. оператор && возвращает первое ложное или последнее истинное значение,
а т.к. true является истинным и 3 также является истинным, то значение в скобках будет равно просто 3.

2. Boolean(3) будет равно true, т.к. любое ненулевое значение является истинным6 что в итоге даст нам ответ true.

3. true + "d". При конкатенации со строкой значение true также преобразуется в строку "true", что в итоге нам даст "trued".

# Метод запроса OPTIONS

метод запроса OPTIONS - один из видом запроса протокола HTTP. Цель его использования - получение информации о возможности установления коммуникации для определенного сервера.

## Случаи, когда он вызывается

Данный метод вызывается, когда клиент хочет узнать какие методы HTTP (например, GET, Post и т.д.) поддерживает сервер или ресурс при взаимодействии с тем или иным сервером или ресурсом.

## Где используется

1. Метод OPTIONS часто используется в контексте CORS, когда браузер выполняет предварительный (preflight) запрос, чтобы определить, разрешены ли запросы с другого источника (origin) к конкретному ресурсу.

2. Многие API используют метод OPTIONS для автоматического выяснения доступных методов и возможностей определенного эндпоинта.

3. Разработчики могут использовать метод OPTIONS для диагностики и понимания возможностей серверов и их настроек.

## Что передает и принимает

Запрос: Клиент отправляет запрос OPTIONS на указанный URL. 
Ответ: Сервер отвечает на запрос OPTIONS заголовками, которые указывают на допустимые методы и другие настройки. Например:

1. Allow: содержит список HTTP-методов, которые поддерживает ресурс.
2. Access-Control-Allow-Origin: указывает, какие источники могут получить доступ к ресурсу, если запрос был выполнен контекстом CORS.

## Пример запроса

OPTIONS /api/resource HTTP/1.1
Host: example.com
Origin: http://anotherdomain.com
Access-Control-Request-Method: POST

## Ответ

HTTP/1.1 204 No Content
Allow: GET, POST, OPTIONS
Access-Control-Allow-Origin: http://anotherdomain.com

# Ключевые особенности применения "HTTP" Версии 3.0

HTTP версии 3.0 - это третья версия протокола передачи гипертекстовых данных.

1. Основная особенность HTTP/3 заключается в том, что он основан на протоколе QUIC (Quick UDP Internet Connections), который работает поверх UDP (User Datagram Protocol), а не TCP (Transmission Control Protocol)
2. Поскольку QUIC использует UDP, он лучше справляется с потерей пакетов и задержками в сетях, обеспечивая более быструю передачу данных. QUIC может восстанавливать потерянные пакеты без необходимости повторной передачи всей последовательности, что значительно повышает производительность.
3. HTTP.3 поддерживает мультиплексирование потоков, что позволяет отправлять несколько запросов и получать несколько ответов одновременно по одному соединению. Это устраняет проблему "головной задержки" (head-of-line blocking), которая была характерна для HTTP.2 из-за использования TCP.
4. HTTP.3 строится с акцентом на безопасность, используя шифрование по умолчанию. QUIC поддерживает TLS (Transport Layer Security), что делает соединение более защищенным на уровне подключения.
5. QUIC уменьшает время, необходимое для установления соединения, за счет использования "нулевой раунд-трип" (0-RTT) при повторных соединениях, что позволяет клиенту отправлять данные сразу после отправки запроса на соединение.
6. QUIC обеспечивает более эффективный контроль потока и управление перегрузками, что помогает оптимизировать передачу данных в зависимости от текущих сетевых условий.
7. HTTP.3 разработан с учетом обратной совместимости, позволяя работать с предыдущими версиями HTTP и упрощая процесс миграции для веб-разработчиков и серверных администраторов.

# Способы отмены запросов, включая AbortController

AbortController — это интерфейс, который позволяет контролировать выполнение HTTP-запросов и других асинхронных операций, таких как fetch. Он позволяет отменять запросы, если они больше не нужны, что может быть полезно для улучшения производительности и предотвращения ненужных операций.

## Использование AbortController с Fetch API

### Создание экземпляра AbortController:
 
const controller = new AbortController();
const signal = controller.signal;

### Отправка запроса с использованием сигнала:

fetch('https://api.example.com/data', { signal })
    .then(response => {
        if (!response.ok) {
            throw new Error('Network response was not ok');
        }
        return response.json();
    })
    .then(data => {
        console.log(data);
    })
    .catch(err => {
        if (err.name === 'AbortError') {
            console.log('Fetch aborted');
        } else {
            console.error('Fetch error:', err);
        }
    });

### Отмена запроса:

controller.abort();

## Применение AbortController в асинхронных операциях

Вы также можете использовать AbortController в других асинхронных операциях. Например, если вы используете XMLHttpRequest, вы можете делать это следующим образом:
 
const controller = new AbortController();
const signal = controller.signal;

const xhr = new XMLHttpRequest();
xhr.open('GET', 'https://api.example.com/data');

// Обработчик события для обработки отмены
signal.addEventListener('abort', () => {
    xhr.abort(); // Отменяем запрос XMLHttpRequest
});

// Обработка успешного ответа
xhr.onload = () => {
    if (xhr.status === 200) {
        console.log(JSON.parse(xhr.responseText));
    }
};
// Отмена запроса
controller.abort();
xhr.send();

## Другие способы отмены запросов

1. Использование таймеров: Вы можете установить таймер, по истечении которого ваш запрос будет отменен.

2. Пользовательские события: Вы можете слушать события, такие как клики мыши или нажатия клавиш, чтобы решать, нужно ли отменять выполнение запроса.

3. Управление состоянием: Если вы используете библиотеки для управления состоянием (например, Redux), вы можете управлять состоянием выполнения запроса и отменять его по условиям.

# Способы создания примитивных значений

## String
 1. Можно использовать одинарные ковычки:

 let str = 'Hello, world!';

 2. Можно использовать двойные ковычки:

 let str = "Hello world!";

 3. Можно использовать литерал:
 
  let str = 'Farid';
  console.log(`Hello, ${name}`); // "Hello, Farid"


## Number
1. Объявление целого чила через переменную или через константу:

let num = 1;
const num = 1;

2. Объявление нецелого числа с плавающей точкой через переменную или константу:

let num = 3.14;
const num = 3.14;

3. Через использование встроенного метода Number():

let num = Number("1"); // 1

##  Boolean
1. Прямое присваивание значения:
 let str = true;
 let str1 = false;

2. Через логическое выражение:
let str = (1 > 0); // true
let str = (1 < 0); // false

## Null
1. Через прямое создание значения null:
let val = null;

## Undefined
1. Через прямое создание значения undefined:
let val; // переменная была объявлена, но значение присвоено не было

## Symbol
1. Создание символа через Symbol() с описанием и без него:
let symb = Symbol('inicialization');
let symb = Symbol();

## BigInt
1. Создание через использование суффикса n в конце:
let num = 12345673534365767n;

2. Создание BigInt с помощью встроенного метода BigInt():
let num = BigInt(546546345);

# Почему, если обратиться к переменным созданным через let, const до их объявления - мы получаем ReferenceError? 

### Объяснение:

При использовании переменных, созданных с помощью let и const, в JavaScript существует концепция, называемая "временной мертвой зоной" (Temporal Dead Zone, TDZ).

Когда вы пытаетесь получить доступ к переменной, объявленной с помощью let или const, до ее объявления в коде, возникает ошибка ReferenceError. Это связано с тем, что такие переменные не инициализируются до тех пор, пока не будет выполнено их объявление. Временная мертвая зона — это область кода, где переменная существует (то есть она объявлена), но еще не инициализирована.

### Пример:

concole.log(a); // ReferenceError: Cannot access 'a' before initialization

let a = 1;